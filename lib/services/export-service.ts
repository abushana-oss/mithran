/**
 * Export Service for Cost Analysis Reports
 * Supports PDF and Excel export formats
 */

import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';

export interface ExportData {
  bomName: string;
  bomId: string;
  projectName?: string;
  summary: {
    totalCost: number;
    sellingPrice: number;
    totalMargin: number;
    averageSga: number;
    averageProfit: number;
    rawMaterials: number;
    processCosts: number;
    packagingLogistics: number;
    procuredParts: number;
    overheadCosts: number;
  };
  costBreakdown?: any[];
  assemblies?: any[];
  timestamp: string;
}

export type ExportFormat = 'pdf' | 'excel';

export class ExportService {
  private static instance: ExportService;

  public static getInstance(): ExportService {
    if (!ExportService.instance) {
      ExportService.instance = new ExportService();
    }
    return ExportService.instance;
  }

  /**
   * Export cost analysis data in the specified format
   */
  public async exportCostAnalysis(data: ExportData, format: ExportFormat): Promise<void> {
    try {
      if (format === 'pdf') {
        await this.exportToPDF(data);
      } else if (format === 'excel') {
        await this.exportToExcel(data);
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw new Error(`Failed to export as ${format.toUpperCase()}`);
    }
  }

  /**
   * Export to PDF format
   */
  private async exportToPDF(data: ExportData): Promise<void> {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    let yPosition = 20;

    // Header
    doc.setFontSize(20);
    doc.setTextColor(40, 40, 40);
    doc.text('Cost Analysis Report', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 15;

    // BOM Information
    doc.setFontSize(14);
    doc.text(`BOM: ${data.bomName}`, 20, yPosition);
    yPosition += 10;
    doc.setFontSize(10);
    doc.text(`BOM ID: ${data.bomId}`, 20, yPosition);
    yPosition += 8;
    doc.text(`Generated: ${data.timestamp}`, 20, yPosition);
    yPosition += 20;

    // Cost Summary Section
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text('Cost Summary', 20, yPosition);
    yPosition += 15;

    doc.setFontSize(10);
    const summaryItems = [
      ['Total Cost:', this.formatCurrencyForPDF(data.summary.totalCost)],
      ['Selling Price:', this.formatCurrencyForPDF(data.summary.sellingPrice)],
      ['Total Margin:', this.formatCurrencyForPDF(data.summary.totalMargin)],
      ['Average SGA:', this.formatPercentage(data.summary.averageSga)],
      ['Average Profit:', this.formatPercentage(data.summary.averageProfit)],
    ];

    summaryItems.forEach(([label, value]) => {
      doc.text(label, 20, yPosition);
      doc.text(value, 100, yPosition);
      yPosition += 8;
    });

    yPosition += 10;

    // Cost Breakdown Section
    doc.setFontSize(12);
    doc.text('Cost Breakdown', 20, yPosition);
    yPosition += 15;

    doc.setFontSize(10);
    const breakdownItems = [
      ['Raw Materials:', this.formatCurrencyForPDF(data.summary.rawMaterials), this.formatPercentage((data.summary.rawMaterials / data.summary.totalCost) * 100)],
      ['Process Costs:', this.formatCurrencyForPDF(data.summary.processCosts), this.formatPercentage((data.summary.processCosts / data.summary.totalCost) * 100)],
      ['Packaging & Logistics:', this.formatCurrencyForPDF(data.summary.packagingLogistics), this.formatPercentage((data.summary.packagingLogistics / data.summary.totalCost) * 100)],
      ['Procured Parts:', this.formatCurrencyForPDF(data.summary.procuredParts), this.formatPercentage((data.summary.procuredParts / data.summary.totalCost) * 100)],
      ['Overhead Costs:', this.formatCurrencyForPDF(data.summary.overheadCosts), this.formatPercentage((data.summary.overheadCosts / data.summary.totalCost) * 100)],
    ];

    breakdownItems.forEach(([label, value, percentage]) => {
      doc.text(label, 20, yPosition);
      doc.text(value, 80, yPosition);
      doc.text(percentage, 140, yPosition);
      yPosition += 8;
    });

    // Add totals
    yPosition += 5;
    doc.setDrawColor(0, 0, 0);
    doc.line(20, yPosition, 160, yPosition);
    yPosition += 8;
    doc.setFontSize(10);
    doc.text('Total:', 20, yPosition);
    doc.text(this.formatCurrencyForPDF(data.summary.totalCost), 80, yPosition);
    doc.text('100.0%', 140, yPosition);

    // Footer
    const pageHeight = doc.internal.pageSize.height;
    doc.setFontSize(8);
    doc.setTextColor(128, 128, 128);
    doc.text('Generated by Manufacturing Cost Analysis Engine', pageWidth / 2, pageHeight - 10, { align: 'center' });

    // Save the PDF
    const fileName = `Cost_Analysis_${data.bomName}_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
  }

  /**
   * Export to Excel format
   */
  private async exportToExcel(data: ExportData): Promise<void> {
    const workbook = XLSX.utils.book_new();

    // Summary Sheet
    const summaryData = [
      ['Cost Analysis Report'],
      [''],
      ['BOM Name', data.bomName],
      ['BOM ID', data.bomId],
      ['Generated', data.timestamp],
      [''],
      ['Cost Summary'],
      ['Metric', 'Value'],
      ['Total Cost', this.formatCurrency(data.summary.totalCost)],
      ['Selling Price', this.formatCurrency(data.summary.sellingPrice)],
      ['Total Margin', this.formatCurrency(data.summary.totalMargin)],
      ['Average SGA', this.formatPercentage(data.summary.averageSga)],
      ['Average Profit', this.formatPercentage(data.summary.averageProfit)],
      [''],
      ['Cost Breakdown'],
      ['Category', 'Amount', 'Percentage'],
      ['Raw Materials', this.formatCurrency(data.summary.rawMaterials), this.formatPercentage((data.summary.rawMaterials / data.summary.totalCost) * 100)],
      ['Process Costs', this.formatCurrency(data.summary.processCosts), this.formatPercentage((data.summary.processCosts / data.summary.totalCost) * 100)],
      ['Packaging & Logistics', this.formatCurrency(data.summary.packagingLogistics), this.formatPercentage((data.summary.packagingLogistics / data.summary.totalCost) * 100)],
      ['Procured Parts', this.formatCurrency(data.summary.procuredParts), this.formatPercentage((data.summary.procuredParts / data.summary.totalCost) * 100)],
      ['Overhead Costs', this.formatCurrency(data.summary.overheadCosts), this.formatPercentage((data.summary.overheadCosts / data.summary.totalCost) * 100)],
    ];

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Cost Summary');

    // Raw Data Sheet
    if (data.costBreakdown && data.costBreakdown.length > 0) {
      const rawDataSheet = XLSX.utils.json_to_sheet(data.costBreakdown);
      XLSX.utils.book_append_sheet(workbook, rawDataSheet, 'Raw Data');
    }

    // Save the Excel file
    const fileName = `Cost_Analysis_${data.bomName}_${new Date().toISOString().split('T')[0]}.xlsx`;
    XLSX.writeFile(workbook, fileName);
  }

  /**
   * Prepare export data from aggregated cost data
   */
  public prepareExportData(
    bomId: string,
    bomName: string,
    aggregated: any,
    costData?: any[],
    projectName?: string
  ): ExportData {
    return {
      bomId,
      bomName,
      projectName,
      summary: {
        totalCost: aggregated.totalCost || 0,
        sellingPrice: aggregated.totalSellingPrice || 0,
        totalMargin: aggregated.totalMargin || 0,
        averageSga: aggregated.averageSgaPercentage || 0,
        averageProfit: aggregated.averageProfitPercentage || 0,
        rawMaterials: aggregated.totalRawMaterials || 0,
        processCosts: aggregated.totalProcessCosts || 0,
        packagingLogistics: aggregated.totalPackagingLogistics || 0,
        procuredParts: aggregated.totalProcuredParts || 0,
        overheadCosts: ((aggregated.totalRawMaterials || 0) + (aggregated.totalProcessCosts || 0) + (aggregated.totalPackagingLogistics || 0) + (aggregated.totalProcuredParts || 0)) * 0.15, // Calculate 15% overhead from direct costs
      },
      costBreakdown: costData || [],
      timestamp: new Date().toLocaleString(),
    };
  }

  /**
   * Show export format selection dialog
   */
  public async showExportDialog(): Promise<ExportFormat | null> {
    return new Promise((resolve) => {
      const dialog = document.createElement('div');
      dialog.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
        ">
          <div style="
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 300px;
            text-align: center;
          ">
            <h3 style="margin: 0 0 16px 0; color: #374151;">Export Format</h3>
            <p style="margin: 0 0 24px 0; color: #6b7280; font-size: 14px;">
              Choose your preferred export format:
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
              <button id="exportPDF" style="
                background: #ef4444;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
              ">ðŸ“„ PDF</button>
              <button id="exportExcel" style="
                background: #10b981;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
              ">ðŸ“Š Excel</button>
              <button id="cancelExport" style="
                background: #6b7280;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
              ">Cancel</button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(dialog);

      const cleanup = () => {
        document.body.removeChild(dialog);
      };

      dialog.querySelector('#exportPDF')?.addEventListener('click', () => {
        cleanup();
        resolve('pdf');
      });

      dialog.querySelector('#exportExcel')?.addEventListener('click', () => {
        cleanup();
        resolve('excel');
      });

      dialog.querySelector('#cancelExport')?.addEventListener('click', () => {
        cleanup();
        resolve(null);
      });
    });
  }

  private formatCurrency(value: number): string {
    // Use Rs. instead of â‚¹ symbol for PDF compatibility
    return `Rs. ${value.toLocaleString('en-IN', { minimumFractionDigits: 2 })}`;
  }
  
  private formatCurrencyForPDF(value: number): string {
    // Use INR prefix for PDF to avoid font issues
    return `INR ${value.toLocaleString('en-IN', { minimumFractionDigits: 2 })}`;
  }

  private formatPercentage(value: number): string {
    return `${value.toFixed(1)}%`;
  }
}

// Export singleton instance
export const exportService = ExportService.getInstance();